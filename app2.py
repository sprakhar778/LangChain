import os
import re
import tempfile
import streamlit as st
from dotenv import load_dotenv
from langchain.prompts import ChatPromptTemplate
from langchain.schema import SystemMessage, HumanMessage
from langchain_groq import ChatGroq
from fpdf import FPDF
 
# Load API key
load_dotenv()
GROQ_API_KEY = os.getenv("GROQ_API_KEY")
 
# Init LLM
llm = ChatGroq(
    model="deepseek-r1-distill-llama-70b",
    temperature=0.3,
    api_key=GROQ_API_KEY
)
 
# Streamlit UI
st.set_page_config(page_title="Medical Device Reporter", page_icon="ðŸ©º")
st.title("ðŸ©º Medical Device Report Generator")
st.markdown("Enter the **device name**. You'll get a structured report based on regulatory data (ASTM, ISO, FDA, etc.)")
 
device_name = st.text_input("**Device Name**", placeholder="e.g., Total Knee Implant")
generate_button = st.button("ðŸš€ Generate Report")
 
# Prompt
SYSTEM_PROMPT = """
You are a regulatory expert generating a structured technical report for a medical device.
Respond with only the following 6 sections, using bullet points and subpoints for clarity:
 
1. **Material of Construction**
2. **Mechanical Properties**
3. **Degradation Profile**
4. **Dimension and Structural Integrity**
5. **Performance Criteria**
6. **Functional Requirements**
 
ðŸ’¡ Rules:
- Only include data commonly applicable to the specific device.
- Use real ASTM/ISO/FDA standards where possible.
- Do NOT hallucinate or fill in unknown data.
- Include approximate or typical ranges (e.g., 860-1000 MPa) where applicable.
- Use bullet points or short lines per item. No prose.
 
Device: {device_name}
"""
 
# Enhanced PDF Generator
def generate_pdf_from_text(text: str, device_name: str) -> str:
    class StyledPDF(FPDF):
        def header(self):
            # Draw a colored header on each page (except cover)
            if self.page_no() > 1:
                self.set_fill_color(0, 102, 204)  # A modern blue shade
                self.rect(0, 0, self.w, 20, style="F")
                self.set_y(5)
                self.set_font("Helvetica", "B", 12)
                self.set_text_color(255, 255, 255)
                self.cell(0, 10, "Medical Device Technical Report", border=0, ln=True, align="C")
            
        def footer(self):
            # Add a footer with page numbers on each page (except cover)
            if self.page_no() > 1:
                self.set_y(-15)
                self.set_font("Helvetica", "I", 8)
                self.set_text_color(128, 128, 128)
                self.cell(0, 10, f"Page {self.page_no()-1}", 0, 0, "C")
        
        def add_cover_page(self, device_name):
            # Cover page with a stylish layout
            self.add_page()
            self.set_font("Helvetica", "B", 28)
            self.set_text_color(0, 102, 204)
            self.cell(0, 60, "", ln=True)  # Vertical spacing
            self.cell(0, 20, "Medical Device Technical Report", ln=True, align="C")
            self.ln(10)
            self.set_font("Helvetica", "", 20)
            self.set_text_color(64, 64, 64)
            self.cell(0, 20, f"Device: {device_name}", ln=True, align="C")
            self.ln(20)
            self.set_font("Helvetica", "I", 12)
            self.cell(0, 20, "Generated by Medical Device Reporter", ln=True, align="C")
            
            # Add date
            from datetime import datetime
            today = datetime.now().strftime("%B %d, %Y")
            self.ln(10)
            self.set_font("Helvetica", "", 10)
            self.cell(0, 10, f"Date: {today}", ln=True, align="C")

        def section_title(self, title):
            # Section header with background fill for style
            self.set_font("Helvetica", "B", 14)
            self.set_fill_color(230, 240, 255)  # light blue fill
            self.set_text_color(0, 0, 0)
            self.cell(0, 10, title, border=0, ln=True, fill=True)
            self.ln(2)

        def bullet_text(self, text, level=0):
            indent = 5 * (level + 1)
            self.set_x(indent)
            
            # Calculate text width to determine if it will fit
            text_width = self.get_string_width(text) + 2  # Add a little margin
            available_width = self.w - self.r_margin - self.x
            
            if text_width <= available_width:
                self.cell(0, 6, text, ln=True)
            else:
                # Split into multiple lines if too wide
                words = text.split()
                line = ""
                for word in words:
                    test_line = line + " " + word if line else word
                    if self.get_string_width(test_line) < available_width:
                        line = test_line
                    else:
                        self.cell(0, 6, line, ln=True)
                        self.set_x(indent)  # Reset indent for next line
                        line = word
                if line:  # Print the last line
                    self.cell(0, 6, line, ln=True)

    # Create instance of StyledPDF
    pdf = StyledPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_cover_page(device_name)
    pdf.add_page()
    
    # Parse sections more robustly
    # First, try to split by numbered sections
    sections = []
    current_section = {"title": "", "content": []}
    
    # Parse report content into structured sections
    lines = text.strip().split('\n')
    section_pattern = re.compile(r'^(?:\d+\.\s+)?\*\*([^*]+)\*\*')
    
    current_section = None
    
    for line in lines:
        section_match = section_pattern.match(line)
        
        if section_match:
            # If we found a new section title
            if current_section:
                sections.append(current_section)
            
            current_section = {
                "title": section_match.group(1).strip(),
                "content": []
            }
        elif current_section is not None:
            # Add content to current section
            current_section["content"].append(line.strip())
    
    # Add the last section
    if current_section:
        sections.append(current_section)
    
    # If no sections were detected, try an alternative approach
    if not sections:
        # Try to split by section headers (####)
        section_pattern = re.compile(r'^####\s+(.*?)$')
        for line in lines:
            section_match = section_pattern.match(line)
            
            if section_match:
                if current_section:
                    sections.append(current_section)
                
                current_section = {
                    "title": section_match.group(1).strip(),
                    "content": []
                }
            elif current_section is not None:
                current_section["content"].append(line.strip())
        
        # Add the last section
        if current_section:
            sections.append(current_section)
    
    # If still no sections, create a single section with all content
    if not sections:
        sections = [{"title": "Report Content", "content": lines}]
    
    # Render each section
    for section in sections:
        if section["title"]:
            pdf.section_title(section["title"])
        
        pdf.set_font("Helvetica", "", 10)
        
        for line in section["content"]:
            if not line.strip():
                pdf.ln(2)
                continue
                
            line = line.strip()
            indent_level = 0
            
            # Determine indentation level - using Latin-1 compatible characters
            if line.startswith('- '):
                indent_level = 0
                line = '* ' + line[2:]  # Use asterisk instead of bullet
            elif line.startswith('  - '):
                indent_level = 1
                line = '- ' + line[4:]  # Use hyphen instead of circle bullet
            elif line.startswith('    - '):
                indent_level = 2
                line = '+ ' + line[6:]  # Use plus instead of square bullet
            
            # Handle bullet points and indentation
            if indent_level > 0:
                pdf.bullet_text(line, indent_level)
            else:
                # For normal text or top-level bullets
                if line.startswith('*'):
                    pdf.bullet_text(line, 0)
                else:
                    pdf.set_x(5)
                    # Handle potential bolded text
                    if '**' in line:
                        parts = line.split('**')
                        is_bold = False
                        line_width = 0
                        for part in parts:
                            if part:
                                pdf.set_font("Helvetica", "B" if is_bold else "")
                                pdf.cell(pdf.get_string_width(part), 6, part, ln=0)
                            is_bold = not is_bold
                        pdf.ln()
                    else:
                        pdf.multi_cell(0, 6, line)
            
        pdf.ln(3)
    
    safe_name = re.sub(r'[^a-zA-Z0-9_]', '_', device_name)
    temp_pdf = tempfile.NamedTemporaryFile(delete=False, suffix=f"_{safe_name}.pdf")
    pdf.output(temp_pdf.name)
    return temp_pdf.name
if generate_button:
    if not device_name:
        st.warning("Please enter a device name.")
    else:
        with st.spinner("Generating structured report..."):
            prompt = ChatPromptTemplate.from_messages([
                SystemMessage(content=SYSTEM_PROMPT),
                HumanMessage(content=f"{device_name}")
            ])
            try:
                messages = prompt.format_messages(device_name=device_name)
                response = llm(messages)
                clean_output = re.sub(r"<think>.*?</think>", "", response.content, flags=re.DOTALL).strip()
 
                st.success("\u2705 Report generated successfully!")
                st.markdown(clean_output)
 
                # PDF export
                pdf_path = generate_pdf_from_text(clean_output, device_name)
                with open(pdf_path, "rb") as f:
                                        # âœ… Replace it with:
                    st.download_button("Download Report as PDF", f, file_name=f"{device_name}_report.pdf", mime="application/pdf")
            except Exception as e:
                st.error("\u26a0\ufe0f Failed to generate report.")
                st.exception(e)
 